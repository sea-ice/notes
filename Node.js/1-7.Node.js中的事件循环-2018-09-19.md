### Node.js中的事件

Node.js中提供了EventEmitter这个类来实现订阅-发布模式（Pub/Sub机制）。和浏览器端事件处理机制不同的是，Node.js中通过EventEmitter订阅的事件是同步触发的。举例：

```javascript
let EventEmitter = require('events')
let utils = require('util')

function MyEventEmitter() {}
utils.inherits(MyEventEmitter, EventEmitter)
MyEventEmitter.prototype.fire = function fire() {
	console.log('Before emit')
	this.emit('fire')
	console.log('After emit')
}

let emitter = new MyEventEmitter()
emitter.on('fire', () => {
	console.log('Fire event')
})
emitter.fire()
```

打印结果如下：
Before emit
Fire event
After emit

### Node.js中的事件循环

Node.js中的一次事件循环过程如下图所示：

![](../static/understanding-the-nodejs-event-loop-diagram.png)

从上图可以看出，一次事件循环分多个阶段。此外需要做几点说明：

1. 上图中的pending callback指的是被加入到执行队列等待执行的回调在这个阶段被执行。

2. 每一次事件循环执行的process.nextTick方法，其对应的回调会在当前这一次事件循环的末尾被调用，包括回调里面递归调用的process.nextTick方法中的操作都会在当前这一次事件循环中被执行。所以递归调用process.nextTick方法会导致当次事件循环执行时间过长。举例：

```javascript
process.nextTick(() => {
	setTimeout(() => {
		console.log('setTimeout')
	}, 0)
	process.nextTick(() => {
		console.log('nextTick 2')
		process.nextTick(() =>　{
			console.log('nextTick 4')
		});
		console.log('nextTick 3')
	});
	setImmediate(() => {
		console.log('setImmediate 2')
	});
	console.log('nextTick 1')
});
setImmediate(() => {
	console.log('setImmediate 1')
	process.nextTick(() => {
		console.log('nextTick in setImmediate 1')
	})
});
// 运行结果如下：
// nextTick 1
// nextTick 2
// nextTick 3
// nextTick 4
// <新的事件循环开始>
// setTimeout
// setImmediate 1
// setImmediate 2
// nextTick in setImmediate 1
```

3. 每一次事件循环执行的setTimeout和setImmediate函数，其对应的回调会在下一次事件循环中被执行。