Node.js中的Stream支持两种操作模式：

1. 二进制模式。在此模式下，流中的数据是以块的形式存在的，比如Buffer对象或者字符串；
2. 对象模式。在此模式下，流中的数据被看作是一系列独立的对象。

## Stream分类

Stream可以分为以下四类：

1. 可读流Readable
   
   可读流数据流向：可读流_read方法push data -> 可读流内部buffer -> readable事件处理函数中read或者触发data事件

   可读流数据获取存在两种模式：
   （1）、非流动模式：当内部缓冲区有数据时，触发readable事件，在readable事件处理函数中通过read方法显式获取缓冲区中的数据；切换到non-flow模式的集中方式：
   a. 如果没有管道目标，调用 stream.pause() 方法；
   b. 如果有管道目标，移除所有管道目标。调用 stream.unpipe() 方法可以移除多个管道目标。
   （2）、流动模式：当内部缓冲区有数据时，触发data事件，在data事件处理函数中直接获取到数据。切换到flow模式的几种方式：
   a. 新增一个 'data' 事件处理函数;
   b. 调用 stream.resume() 方法;
   c. 调用 stream.pipe() 方法发送数据到可写流。

   自定义可读流类型需要定义_read方法，在_read方法中通过push方法将数据放到缓冲区中，最后通过push(null)来结束。如果在调用一次_read方法中，如果出现多次调用push方法，则需要判断push方法的返回值是否为false，如果为false，则说明缓冲区中的数据超出了设定的highWaterMark的限制，因此需要暂停push。
   事件：
   （1）、readable事件
   （2）、data事件
   （3）、end事件
   （4）、error事件

   可读流继承于Stream，同时Stream又继承于EventEmitter类，Readable类具有的on方法不同于普通的EventEmitter类的on监听方法，而是在EventEmitter类的on方法的基础上进行增强，该方法内部会根据监听的事件类型自动开始流中数据的读取，如果是监听readable事件，则会调用read(0)；如果是监听data事件，则会调用resume方法，内部其实也会调用read(0)。接下来，在non-flow模式下接入正常的工作流的过程：从read(0)方法开始 -> 调用_read方法 -> _read方法内部调用push方法或者unshift方法 -> readableAddChunk -> addChunk -> 将chunk添加到state.buffer中 -> 触发readable事件，内部调用read()。注read()和read(0)两者是不同的，前者会返回当前state.buffer中的数据，而后者则可能返回null。

   而在flow模式下接入正常的工作流的过程：从read(0)方法开始 -> 调用_read方法 -> _read方法内部调用push方法或者unshift方法 -> 在read方法最后触发data事件
   如果push或者unshift方法传入的参数为null，则会设置state.ended为true，进而触发end事件

2. 可写流Writable
   
   可写流数据流向：可写流调用write方法 -> 调用可写流对象的_write方法，传入chunk、encoding、callback等参数
   可写流存在一个背压（back pressure）问题，在调用write方法时会返回是否超出了初始时设置的highWaterMark值，然后再决定是否可以继续调用write方法。这是为了兼顾到消费者的消费速率。在没有调用end方法的前提下，在每一次执行write方法的最后，都会检查待写入的内容大小是否超出水位线，如果超出，则在被消费者消费（定义的_write方法）之后会触发drain事件。在drain事件处理函数中可以继续调用write方法，提供数据供消费者消费。
   事件：
   （1）、pipe事件
   （2）、unpipe事件
   （3）、drain事件
   （4）、finish事件：可写流调用了end方法之后触发
  
3. 双向流Duplex
   
   双向流Duplex既是Readable，也是Writable。跟Readable和Writable一样，Duplex需要定义_read和_write方法。

4. 变换流Transform
   
   变换流Transform是一种特殊的双向流Duplex，内部已经实现了_read和_write方法，而与一般流不同的是，变换流Transform需要实现_transform方法。正常工作流程是：write方法 -> _write方法 -> _read方法 -> _transform方法，该方法会接收write方法传入的chunk、encoding参数以及转换完成的回调函数callback。该callback函数是内部定义的，外部需要传入可能出错时的err和新的data，如果传入了新的数据data，该callback内部会调用push方法，然后触发readable或者data事件；然后会调用前面write方法传入的回调函数，表示写入完成或失败；最后会调用_read方法，注意_write与_read方法和Writable的_write方法与Readable的_read方法是不一样的。

   在自定义的_transform方法中需要调用传入的转换完成的回调callback才能进行下一轮的转换。

   转换流实现无序并列处理流，这种操作方式在对象流中很常见，而在二进制模式中几乎不会使用。
   