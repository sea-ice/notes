## Node.js中的异步IO

### 基础概念

非阻塞IO和阻塞IO的区别在于非阻塞IO在调用之后立即返回，不阻塞当前线程后续的执行，而阻塞IO需要CPU等待IO操作返回结果再向下执行，会白白浪费CPU资源。

非阻塞IO因为没有立即返回结果，所以需要一些手段来辅助判断当前IO操作是否完成，传统的解决方案是通过轮询的手段去判断的，也就是重复去获取当前的状态。具体的方法要么就是遍历文件描述符的状态（比如典型的select、poll技术），要么就是在IO操作期间对CPU进行休眠，直到事件发生将其唤醒（比如Linux中的epoll）。

通过轮询的方法并没有完全利用CPU资源，依然是将CPU资源进行闲置或者用于操作结果的判断上。理想的非阻塞IO应该是在调用之后CPU能够继续处理后续的任务，等到IO操作完成只需将结果传递并执行对应的回调即可。

事实是可以通过线程池来模拟异步IO，原理是由线程池中的部分线程进行IO操作，也就是数据获取操作，由另外一个线程负责在其他线程IO操作完成时将操作的结果进行传递，由此实现异步IO。基于这样的思想，在Unix系统下可以通过自定义线程池进行实现，而在windows下也有对应的IOCP这种异步IO实现。

由于windows和Unix系统的差异，Node提供了libuv作为抽象封装层。

构成Node异步IO的重要组成部分：事件循环、请求对象。

在JavaScript发起IO操作到内核执行完IO操作的过程中，存在请求对象这种中间产物。请求对象需要保存在完成IO操作之后需要被自动调用的回调函数（就是包装的过程），请求对象包装完成后就会被推入线程池中等待执行。当线程池分配的线程执行完IO操作之后，会将操作结果保存到请求对象上，同时会通知IOCP对象操作已经完成。

接着在每次事件循环中，事件循环对象loop会调用IOCP对象上的方法检查是否有执行完成的请求对象，如果有，会把该请求对象添加到loop对象上；同时每次事件循环也会不断检查loop对象是否有已完成的请求对象，如果有，则取出该请求对象，并把请求对象上保存的操作结果传递给该对象上保存的回调函数执行。至此，整个异步IO的流程结束。