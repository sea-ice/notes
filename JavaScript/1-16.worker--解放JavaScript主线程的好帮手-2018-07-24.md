### web worker

web worker机制用于开启一个完全独立的线程，执行一系列计算任务，避免繁重的计算任务阻塞了JavaScript主线程。worker之间以及它们和主程序之间不会共享任何作用域或资源，从而避免了多线程编程中复杂的锁机制。取而代之的是，它们之间是通过事件消息机制进行通信的。

```javascript
let worker = new Worker('/path/to/js')
worker.onmessage = e => {}
// or
worker.addEventListener('message', e => {})
worker.postMessage(data)

// worker.js
onmessage = e => {}
postMessage(data)
// or
addEventListener('message', e => {})
```

在worker执行的JavaScript脚本中，不能够同主线程一样访问和操作DOM，同时也只有部分API可以使用，包括执行网络请求（ajax、WebSocket）以及设定定时器（不能使用全局函数requestAnimationFrame），另外可以访问部分全局对象，包括navigator、location、JSON等。

如果需要在worker中引入其他JavaScript脚本提供的工具函数，可以使用importScripts函数引入目标脚本。需要注意的是，通过importScripts函数引入的脚本的加载过程是同步的，意味着调用importScripts函数会阻塞后续代码的执行。

前面提到了，主线程和worker线程是完全独立的，它们之间的通信也是通过事件消息机制完成的，而数据的传递方式有以下这两种：

1. 结构化克隆算法。该算法可以对对象进行复制，同时也处理对象循环引用的情况。优势在于可以避免原始的复制过程中to-string和from-string的性能损失。但是这种方法需要使用双倍的内存。主流浏览器均支持这种方法。
2. 使用Transferable对象，尤其是对于大数据集的处理。这种方法的本质是将对象的所有权进行转移，数据本身不需要移动。如果是使用这种方法，则当将数据通过事件消息传递到worker线程时，在原来的线程中引用该对象的变量就暂时为空或者不可访问。这种转移对象所有权的方法可以双向进行。任何实现了Transferable接口的数据结构（比如ArrayBuffer、MessagePort、ImageBitmap等对象）在线程间传递时会自动按照这种方式进行传递。举例：

```javascript
// 例如Uint8Array数组就实现了Transferable接口，使用postMessage方法传递Transferable对象具体方式如下（假设foo是一个Uint8Array对象）：
postMessage(foo.buffer, [foo.buffer]) // 其中第一个参数是可以通过结构化克隆算法进行复制的任意的JavaScript对象，第二个参数是一个可选的Transferable对象的数组，用于传递所有权
```


