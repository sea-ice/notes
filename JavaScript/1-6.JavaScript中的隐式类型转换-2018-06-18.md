### 引言
> JavaScript中的强制类型转换问题一直都很让人困扰，不仅仅是因为转换规则之多，而且有些代码在不经意间就发生了隐式类型转换，难以察觉，比如`[] == ![]`返回的结果是`true` ，这就是隐式类型转换造成的结果，乍一看好像也不好理解。所以我觉得有必要抽出时间将常见的隐式类型转换的场景整理成文。

### 强制类型转换
`JavaScript`中的强制类型转换包括显式类型转换和隐式类型转换。下面总结一下这两种类型转换发生的时机以及一些特殊值的转化问题。

#### 显式类型转换

发生显式类型转换的时机：

（1）、`Number`、`String`、`Boolean`构造函数；例如：字符串和数字之间的转换，通过Number和String构造函数实现相互转换，**注意**构造函数之前没有使用`new`关键字，并不创建包装对象，也就是说，通过`Number`和`String`构造函数转换后的结果是基本类型值；而将参数传入`Object`构造函数，会根据传入参数的类型创建包装对象；即`Object("abc")`等价于`new String("abc")`。

除此之外，还可以通过**toString方法**显式转换成字符串；通过**parseInt函数**或者**parseFloat函数**显式转换成数字，如果传入的参数为非字符串，则会先将参数强制类型转换成字符串再进行解析。

字符串转化为数字时如果使用的是`Number`构造函数是转换，如果使用`parseInt`函数则是解析；两者还是有差别的，前者不允许给定字符串中出现非数字字符，而后者允许存在非数字字符，解析会从左到右的顺序，如果遇到超出给定基数的字符或者非数字且非字母字符时会停止解析。

（2）、`“+”`一元操作符，将非数字转换成数字；例如：`Date`对象和数字之间的转换，通过一元操作符`+`实现转换，例如可以通过以下代码获取当前时间戳，`var timestamp = +new Date;`也可以通过`var timestamp = Date.now()`获取。

（3）、`“~”`按位取反；例如：利用按位取反操作符`"~"`可以实现数字与布尔值之间的转换，但前提是数字 `-1` 代表布尔值`false`，其他数字表示真值；按位取反的本质是操作数的相反数减一；

（4）、`“!!”`逻辑非；例如：将非布尔值转化为布尔值，使用**Boolean构造函数**或者 `!!`；

#### 隐式类型转换

发生隐式类型转换的时机：

（1）、算术运算符，如`“+”`、`“-”`、`“*”`、`“/”`，后三者都会把值隐式转化成数字再进行计算；而`“+”`运算符的隐式转换规则如下：

* 如果某个操作数是字符串或者是能够转换成字符串的对象，则`“+”`进行的是拼接操作。否则，如果操作数中有布尔值，则将布尔值隐式转换成数字，例如将`true`转换为`1`，false转换为`0`；然后`“+”`执行的是数字相加操作。

**注意**：将参数传入`String`构造函数，相当于直接调用传入的参数的`toString`方法，这和对象隐式转换成字符串的过程不一样。

（2）、`if`语句中的条件判断表达式；`for`语句中的条件判断表达式；`while`和`do..while`语句中的条件判断表达式；`... ? ... : ...`三元表达式中的条件判断表达式；`&&`和`||`逻辑运算符中的条件判断表达式（运算符左边的操作数）；`&&`和`||`运算符的返回值是两个操作数其中之一；`&&`可以用作守护操作符，操作符左边的表达式可以为右边的表达式把关，例如：

{% highlight javascript %}
a && foo(); // 只在a为真值的情况下才调用foo函数
{% endhighlight %}

（3）、相等运算符（`==`）：比较时遵循以下规则：

* 如果有操作数是布尔值，则先将布尔值转化为数字，`false`转化成`0`，`true`转换成`1`。
* 如果有一个操作数是字符串，另一个是数字，则将字符串转化为数字（通过Number构造函数进行转化，`""`会转化成`0`）。
* 如果有一个操作数是对象，另一个不是，则将对象转化为基本类型值，先调用对象的`valueOf`方法，如果不能转化为基本类型值，则调用对象的`toString`方法，然后按照前面的规则进行比较。

其他规则：
* `null`和`undefined`是相等的；在和其他值比较相等性之前，`undefined`和`null`不会转化为其他值；`+0 === -0; // true`
* 如果是两个对象进行比较，则判断两者是否为同一对象，如果是则返回`true`，否则返回`false`；

（4）、`“<”` `“>”` `“<=”` `“>=”`等关系运算符

* 如果比较的两个操作数经过转换后的基本类型值中出现非字符串，则会将两个操作数强制类型转换成数字进行比较。
* 如果两个操作数转换成的基本类型值都是字符串，则按字母顺序进行比较。

### 一些特殊值的转化

`JavaScript`中也不乏诸如`undefined`、`null`这些特殊值，那他们在实际转换成其它类型值的时候又是怎么进行转化的呢？

（1）、在转化成字符串的时候，`null`会转化成`"null"`，`undefined`会转化成`"undefined"`，`true`会转化成`"true"`，`false`会转化成`"false"`，`NaN`会转化成`"NaN"`，`Infinity`会转化成`"Infinity"`，`[]`会转化成`""`，`[null]`也转化成`""`，数组会转化成`"..，..，.."`格式，函数会转化成`"function...(...) {...}"`，`RegExp`对象会转化成`"/.../.."`格式；除了`null`和`undefined`，其他值都可以通过调用`toString`方法来转化成对应的字符串；

（2）、在转化成数字的时候，`null`会转化成`0`，`""`也转化成`0`，`undefined`会转化成`NaN`，`true`转化为`1`，`false`转化成`0`；所有的值都可以通过传入`Number`函数来转化成对应的数字，另外，需要注意的是，`Number`构造函数对以`0`开头的八进制不会按八进制进行转化，而是按十进制；而对于以`0x`开头的十六进制则会按照十六进制进行转化；例如：

{% highlight javascript %}
console.log(Number("010")); // 10
console.log(Number("0x10")); // 16
{% endhighlight %}

（3）、`JavaScript`中的假值（转换成`false`的值）：`undefined`、`null`、`false`、`+0`、`-0`、`0`和`NaN`、`""`。

（4）、对象在转化成基本类型值时，先调用`valueOf`方法，看能不能转换成基本类型值，如果不能则再调用`toString`方法进行转化；如果还是不能转化成基本类型值，则会报`TypeError`错误。

（5）、关于ES 6中的符号类型（`Symbol`），允许从符号到字符串的显式强制类型转换，隐式类型转换会产生错误；符号不能够被强制类型转换成数字（显式和隐式都会产生错误），但可以被强制类型转换成布尔值（显式和隐式结果都是`true`）。

关于引言中提到的那个不可思议的表达式，之所以得到的结果为`true`，是因为`![]`得到的结果是`false`，而`[]`和`false`在比较相等性的时候，`false`会先转化成数字`0`，`[]`会调用`toString`方法转化成基本类型值`""`，进一步也会转化成数字`0`，因此两者相等。