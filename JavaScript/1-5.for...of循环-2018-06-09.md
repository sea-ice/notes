## for...of循环

ES6中引进了一种新的可以用来遍历可迭代对象（Iterable）的方法，就是for...of循环。在使用for...of循环遍历一个对象之前，需要确保该对象上部署了遍历器接口，也就是需要先定义了[Symbol.iterator]方法，该方法需要返回一个遍历器对象（所谓的遍历器对象指的是具有next方法的对象）。

对于一些原生的数据结构（比如数组、某些类数组对象、Set、Map对象），已经部署了获取遍历器的接口，可以直接使用for...of循环进行遍历。举例：

```javascript
class customArray {
  constructor (start, stop) {
    this.val = this.start = start
    this.stop = stop
  }
  [Symbol.iterator] () {
    return this
  }
  next () {
    let value = this.val++
    return {
      value,
      done: value >= this.stop
    }
  }
}

function range (start, stop) {
  return new customArray(start, stop)
}
for (let val of range(0, 3)) {
  console.log(val) // 0 1 2
} // 注意最后done为true对应的value不会被遍历，即不会被打印
```

综上，for...of循环遍历的对象需要具有[Symbol.iterator]方法，同时该方法需要返回一个遍历器对象（就是需要返回一个具有next方法的对象），而for...of本质上就是在反复调用返回的遍历器对象的next方法获取值。因此for...of循环遍历的对象和最终每次循环获取值的对象没有直接联系。

然而，部署[Symbol.iterator]接口最简便的方式就是将对象上的[Symbol.iterator]方法赋值为一个Generator函数，赋值为Generator函数仅仅只是其中一种方式，本质上就是需要在[Symbol.iterator]方法中返回一个遍历器对象：

```javascript
function range(start, stop) {
  return {
    * [Symbol.iterator] () {
      for (let i = start; i < stop; i++) {
        yield i
      }
    }
  }
}
```

实现的功能和上面的代码完全一样。

## 隐式使用[Symbol.iterator]接口的场景

除了使用for...of循环时会使用[Symbol.iterator]接口外，还有以下这些情况也会隐式使用[Symbol.iterator]接口。

1. 解构赋值

还是用上面的例子进行说明：

```javascript
let [a, b, c] = range(0, 3)
console.log(a, b, c) // 0 1 2
```
2. 扩展运算符

```javascript
let arr = [...range(0, 3)]
console.log(arr) // [0, 1, 2]
```
3. yield*语句

`yield*` 语句用在Generator函数中，作用类似于多个yield语句。`yield*` 语句后面紧跟的是一个Iterable对象，其实际产生值的过程也是通过[Symbol.iterator]接口去获取值。举例：

```javascript
function* yieldVals() {
  yeild* range(0, 3)
}
```



