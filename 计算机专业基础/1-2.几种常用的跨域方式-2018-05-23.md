## 简介

因为浏览器同源策略的限制，JavaScript只能访问同个域名下的资源（比如页面上的DOM、request获取的数据）。对于这种策略的限制，我们也是有几种方式可以来解决的。

### JSONP

JSONP全称是JSON with Padding。意思是后端将需要返回的json数据包装成合法的JavaScript表达式的形式（通常是将数据作为参数传递给回调函数这种形式，前端预先定义好对应的回调函数），然后前端在请求这块数据时通过动态创建script标签来加载以上返回的脚本（利用的就是script标签本身没有同源策略的限制），之后脚本加载成功就会执行对应的回调函数。但是需要注意的一点是，使用JSONP的一个局限性就是对于4xx、5xx这种错误，会终止后续的回调函数的执行，导致我们无法获知错误的发生。在这种情况下的解决方法就是对于这种错误，后端依然返回200状态码，然后将具体的出错信息包含在响应内容中。

### localStorage

如果需要和同源的不同标签页进行通信，可以使用localStorage，当某个标签页设置了localStorage，其他标签页会触发storage事件。

### 其他

websocket不受同源策略的限制，没有跨域的问题

#### 字体文件的加载

CSS字体文件的加载也会存在跨域问题，需要设置CORS才能加载其他域下的字体文件。默认情况下定义新的字体不会立即去下载对应的字体文件，只有当页面上的元素使用了这种字体才会去下载对应的字体文件。

#### canvas中的图片

canvas中动态加载的图片可以直接画到canvas中，但是在将canvas转化成文件对象进行操作时也存在跨域问题，会遇到“Tainted canvases may not be exported”错误。这时候需要对动态加载的图片对象设置crossOrigin属性，同时也需要配置服务器使其支持CORS。

```javascript
let img = new Image()
img.crossOrigin = 'anonymous'
img.src = "//localhost:8888/images/1751527990314_.pic.jpg"
img.onload = () => {
  console.log(img)
  let canvas = document.getElementById('canvas')
  let ctx = canvas.getContext('2d')
  ctx.drawImage(img, 0, 0)
  canvas.toBlob(blob => console.log(blob), 'image/jpeg', .75)
}
```

#### 跨域脚本的错误处理

对于页面上加载的跨域脚本执行出错，页面上绑定的错误处理函数window.onerror在默认情况下是获取不到具体的错误信息的，这时候需要在加载跨域脚本的标签上使用crossorigin属性，也就是在请求跨域脚本的时候执行CORS。crossorigin属性可以设置的值有：

anonymous：请求脚本的时候不会携带凭据
use-credentials：请求脚本的时候携带凭据

设置为其他值都会被看作是anonymous关键字。设置了crossorigin属性意味着还需要对服务器进行配置，使其支持CORS。如果服务端没有正确配置CORS，跨域脚本是无法正常下载的。