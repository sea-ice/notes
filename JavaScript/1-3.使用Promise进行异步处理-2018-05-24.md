## Promise的基本使用

Promise对象可以用于完成一些异步操作。在创建Promise对象时，可以传入一个回调函数，该回调函数**在创建Promise对象时是立即执行的**，并且接收两个函数作为参数，分别用于将Promise对象转化为完成和未完成状态。

Promise对象是thenable的，也就是说，它具有一个then方法，同样接收两个回调函数，分别在Promise对象转化为完成或者未完成状态的时候被调用。同时该方法会**返回一个新的Promise对象**，因此，对于一个Promise对象，可以链式调用then方法。

另外，在将Promise对象转化为完成或者为未完成状态时可以向resolve函数或者reject函数传入一些参数，这样，传递给then方法作为参数的回调函数就可以相应拿到这些数据。这对于在完成异步操作或者异步操作失败时传递下一步操作所需的数据是很有用的。而对于由then方法创建的promise对象向下一级传递数据则是通过**作为then方法接收的回调函数的返回值**来完成的。

在一些情况下，有可能会在then方法的回调函数中返回一个新的Promise对象B，这时候then方法返回的Promise对象A的状态转移就受到对象B的影响，只有当对象B的状态发生改变，对象A的状态才会发生变化。

```javascript
	let p1 = new Promise(function(resolve) {
	  setTimeout(function() {
	    resolve()
	  }, 2000)
	})
	
	let p2 = new Promise(function(resolve, reject) {
	  setTimeout(function() {
	    reject(p1)
	  }, 1000)
	})
	
	p2.then(function() {
	  console.log('Done')
	}, function() {
	  console.log('Rejected')
	})
```

上面的代码运行结果是p2由于在调用reject函数时传入了另外一个Promise对象p1，因此p2的状态实际上是在p1状态转化为完成的时候相应的转化为未完成状态，也就是在代码开始运行的2秒之后。这个例子也说明p2的最终状态并不一定和p1的最终状态是一样的。

需要注意的一点是，调用resolve函数并不意味着Promise对象就一定转化为Resolved状态（比如向resolve函数传入一个新的Promise对象B，则前面的Promise对象的最终状态由Promise对象B的最终状态决定；传入其他值则会将原来的Promise对象转化为Resolved状态），但是调用reject函数确是会将Promise对象修改为Rejected状态。

```javascript
  let p1 = new Promise((resolve, reject) => {
    resolve(new Promise((rs, rj) => {
      rj(new Error('error'))
    }))
  })
  p1.then(() => {
    console.log('resolved')
  }).catch(err => {
    console.log('rejected')
  }) // 'rejected'

  let p1 = new Promise((resolve, reject) => {
    resolve(new Error('error'))
  })
  p1.then(() => {
    console.log('resolved')
  }).catch(err => {
    console.log('rejected')
  }) // 'resolved'
```

## Promise相关接口

### Promise.resolve

该方法主要用于**包装传入的参数，将其转化为Promise对象并返回**。其实**Promise.resolve(arg)的等价写法就是new Promise(resolve => resolve(arg))**。但是这种说法也不全对。比如如果传入的是一个Promise对象，则会直接返回该Promise对象，而不是像new Promise(resolve => resolve(arg))这种写法一样会另外创建一个新的Promise对象：

```javascript
	let p1 = new Promise(function(resolve) {
	  setTimeout(function() {
	    resolve()
	  }, 1000)
	})
	console.log(Promise.resolve(p1) === p1) // true
```

如果不向Promise.resolve方法传入参数，可以创建出一个立即转化为resolved状态的Promise对象，这在某些场景下很有用。

### Promise.reject

该方法会创建一个状态为rejected的Promise对象并返回。

### Promise.all和Promise.race

这两个方法可以接收Promise对象的集合作为参数，如果集合中某些元素不是Promise对象，则会先通过调用Promise.resolve方法进行转化。结果会返回一个新的Promise对象。

对于Promise.all方法返回的Promise对象，只有当传入的所有的Promise对象都转化为resolve状态，它的状态才会相应转化为resolve状态，并且**then方法指定的成功回调会接收所有的Promise对象在调用resolve函数时的参数构成的数组作为参数**。只要有一个Promise对象转化为rejected状态，返回的Promise 对象就转化为rejected，并且**then方法指定的失败回调会接收第一个转化为rejected状态的Promise对象在调用reject函数时传入的参数作为参数**。

对于Promise.race方法返回的Promise对象B，它的状态取决于传入的所有的 Promise对象中状态最先变化的那一个Promise对象A，并且对象B会转化为和对象A一样的状态。在实现告知用户网络请求超时的功能时，Promise.race方法就可以派上用场：

```javascript
	Promise.race([
	  fetch('http://www.example.com'),
	  new Promise((resolve, reject) => {
	    setTimeout(function() {
	      reject('网络连接超时')
	    }, 10000)
	  })
	]).done(data => handleData(data))
	.catch(error => alert(error))
```

## Promise使用注意事项

每个Promise对象都只能转化为Resolved状态，或者是Rejected状态，且一旦状态确定就不可修改。创建Promise对象最基本的方法就是通过向Promise构造函数传入一个函数，在此函数中可以直接执行一些异步操作，然后在异步操作完成或者失败时分别调用函数传入的resolve和reject函数来通知Promise对象状态进行更改。

### 错误捕获

在Promise函数体中抛出的错误，可以被Promise对象后续调用的catch方法所捕获。如果没有使用catch方法进行捕获，在Promise函数体中抛出的错误也不会传递到外层代码。而在Promise对象包含的异步操作中抛出的错误则会直接传递到外层代码，而且catch方法也无法捕获。举例：

```javascript
  new Promise(resolve => {
    setTimeout(() => {
      throw new Error('You never catch me!')
    })
  }).catch(err => {
    console.log(err)
  })
  new Promise((resolve) => {
    throw new Error('Now you can catch me!')
  }).catch(err => {
    console.log(err)
  })
```

![](../static/Promise-error-handle.jpg)

then(resolveHandler).catch(rejectHandler) 并不等价于 then(resolveHandler, rejectHandler)，前者的rejectHandler可以捕获到resolveHandler中抛出的错误，而后者则不能。

### 多个串行操作的实现

使用Promise工厂函数（返回Promise对象的函数），将需要进行的多个操作转化为Promise对象，并通过Promise工厂函数包裹，目的是通过then方法将这些Promise工厂函数进行级联从而实现串行操作。示例代码如下：

```javascript
function executeSequentially(promiseFactories) {
  var result = Promise.resolve();
  promiseFactories.forEach(function (promiseFactory) {
    result = result.then(promiseFactory);
  });
  return result;
}
```

当工厂函数被调用，返回Promise对象时对应的操作才正式开始执行。

### 获取之前操作的结果

举例：

```javascript
getUserByName('nolan').then(function (user) {
  return getUserAccountById(user.id);
}).then(function (userAccount) {
  // dangit, I need the "user" object too!
});
// 此时可以改为如下：
getUserByName('nolan').then(function (user) {
  return getUserAccountById(user.id).then(function (userAccount) {
    // okay, I have both the "user" and the "userAccount"
  });
});
// 一步到位
```

## 与jQuery中的Deferred对象比较

jQuery中也封装实现了类似Promise对象有相同功能的Deferred对象。但是jQuery中的Deferred对象在效果上还是和ES 6规范中的Promise对象有一些不同的地方：

比如在ES 6规范的Promise中，如果**在立即执行函数或者then方法的回调中抛出错误**时，会使得**当前Promise对象状态转化为rejected状态**，但是**程序运行并不会因此而中断**。

```javascript
	let p3 = new Promise(function(resolve) {
	  throw new Error('Error!')
	})
	
	p3.catch(function() {
	  console.log('Rejected first time')
	  y = y + 1 // 程序运行到此处会报错，但依然不会传递到全局作用域
	}).catch(function() {
	  console.log('Rejected twice')
	})
```

上面代码的运行结果如下：

```javascript
	'Rejected first time'
	'Rejected twice'
```

需要注意的是，抛出的错误需要能够被捕获到才会引起Promise对象状态转化为rejected，例如上面举的两种抛错的方式。如果是**在Promise对象内部的异步操作中抛出的错误，不仅不会促使Promise对象转化为rejected，而且还会传递到全局作用域中**。比如：

```javascript
	(new Promise(function(resolve) {
	  setTimeout(function() {
	    throw new Error('Error!')
	  }, 1000)
	})).catch(function() {
	  console.log('Rejected')
	})
```

上面的代码运行1s之后，控制台会直接报错，并且没有打印出'Rejected'。在jQuery的Deferred对象中，一旦在代码中抛出错误了而没有进行捕获，也会像这个结果一样，错误最终会传递到全局作用域中。

另外，在ES 6规范的Promise中，如果在某一环节中，Promise对象转化为未完成状态，则会调用后面离它最近的相应的reject回调，如果在reject回调中程序一切运行正常（这里的正常指的是没有抛出错误，或者回调函数返回了Promise对象，且最终转化为resolved状态），则then/catch方法返回的Promise对象会转化为resolved状态，而不受之前rejected的Promise对象的影响。举例：

```javascript
	let p4 = new Promise(function(resolve, reject) {
	  setTimeout(function() {
	    reject(new Error('Error!'))
	  }, 1000)
	})
	
	p4.then(function() {
	  console.log('Done!')
	}).catch(function(e) {
	  console.log('Error: ' + e)
	}).then(function() {
	  console.log('Anything seems good!')
	})
```

最终程序的运行结果如下：

```javascript
	"Error: Error: Error!"
	"Anything seems good!"
```

而jQuery中的Deferred对象则不一样，一旦在某个环节中Deferred对象转化为未完成状态，而无论之后reject回调执行结果如何，所有的Deferred对象都将转化为rejected。

```javascript
	function asyncOperation() {
		var dtd = $.Deferred()
		setTimeout(function() {
			dtd.reject(new Error('Error!'))
		}, 1000)
		return dtd
	}
	// $.when方法接收一个Deferred对象，将其进行包装并返回一个Promise对象
	$.when(asyncOperation()).fail(function(e) {
		console.log('Error: ' + e.message)
		return e
	}).done(function(data) {
		console.log('Done: ' + data)
	}).fail(function(e) {
		console.log('Error: ' + e.message)
	})
```

上面代码的执行结果如下：

```javascript
	'Error: Error!'
	'Error: Error!'
```

这就好比不小心犯了错误就直接被判死刑了。而ES6中的Promise则刚好截然相反，只要知错能改，依然还是有挽回的余地。因此，应该使用这两者中的哪一个，还是要视具体的应用场景而定。