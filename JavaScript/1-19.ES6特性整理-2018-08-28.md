
## ES6新语法

### 块作用域声明

#### let关键字

let可以用来声明变量，它和var的区别在于如果是在{...}内使用let声明变量，则该变量只能在当前{...}内访问，外界无法访问；而var声明的变量总是归属于函数作用域或者全局作用域。也就是说，let真正赋予了JavaScript块作用域。

如果某个区域内使用let声明变量，则在声明之前不能访问该变量，任何形式的访问都会导致ReferenceError，也就是在let真正声明变量以前该块作用域存在TDZ（Temporal Dead Zone）。也就是说let声明的变量不存在以前版本中出现的变量提升。

对于没有声明的变量，唯一安全的访问该变量的方式就是使用typeof，而在变量的TDZ中使用typeof访问该变量同样会触发ReferenceError。

#### const

const用于声明引用不发生变化的变量，const在声明变量时必须同时对变量进行初始化，const和let一样，同样存在TDZ。

#### 块作用域函数

从ES6开始，块内声明的函数只能在该块内访问，外界无法访问。举例：

```javascript
if (something) {
  function foo () {console.log(1)}
} else {
  function foo () {console.log(2)}
}
foo() // ReferenceError Error
```

在ES6以前，上面的代码中，不管something为何值，最终foo因为函数声明提升的缘故始终指向else块里面声明的函数。而在ES6中则会报错。

### spread/rest运算符

'...'为ES6中的spread/rest运算符，在不同的位置上叫法和作用都有所不同。在对象字面量、数组和函数调用时传递参数时使用，作用就是把给定的值进行展开，此时'...'扮演spread的角色。而在函数声明参数时使用，作用是将函数被调用时可能传入的多个值进行搜集，放到运算符后面的变量指向的数组对象中，同样在对象解构和数组解构赋值符号左侧使用'...'也起到搜集剩余多个值的作用。

### 默认值

默认值出现的位置主要有以下几种：

1. 函数声明参数
   - 默认值参数位置并不一定要出现在所有普通参数之后，也就是说位置随意，除了不能出现在rest参数之后；


对于以上几种默认值，x = yyy 其实等价于 x = (x !== undefined ? x : yyy)，也就是说只有x的值为undefined，x才会被设置为指定的默认值。它和我们经常使用的技巧 x || yyy 并不完全等价。

#### 默认值表达式

默认值除了可以是简单值之外，还可以是其他任何合法的JavaScript表达式；或者说默认值可以是任意合法的JavaScript表达式。另外，作为默认值的JavaScript表达式是惰性求值的，也就是说，只在需要用到默认值的情况下才会去计算表达式的值。

在函数声明的参数列表中使用默认值表达式，表达式中出现的变量查找顺序是在当前参数列表构成的作用域中查找，然后再到函数所在作用域中去查找，但是需要注意可能存在的TDZ。举例：

```javascript
let w = 1, z = 2
function foo (x = w + 1, y = x + 1, z = z + 1) {}
```

上面的函数声明会报ReferenceError，原因就在于z = z + 1这一步存在TDZ，表达式z + 1中的 z 此时还没有被声明就直接被访问，因此会报错。前两个默认值表达式则没有问题。

### 解构

解构分为数组解构和对象解构。解构并不是只能用在声明语句中，它是一个通用的赋值操作，可以用于直接给变量赋值。解构时除了可以赋值给变量以外，还可以赋值给对象上的属性。举例：

```javascript
let o = {}
[o.a, o.b] = [3, 4]
({x: o.x, y: o.y} = {x: 1, y: 2})
console.log(o.x) // 1
```

对于对象解构赋值模式，我们常用的诸如{x, y}={x:1, y: 2}这样的语法其实是一种简写的形式，它等价于{x:x, y:y}={x:1, y: 2}这种形式，只是源属性名和目标变量名一致可以省略罢了。

如果对象解构赋值用于一般的赋值语句中时，需要将整个赋值语句使用(...)进行包裹，避免赋值符号左边的部分被当作是一个块语句而引起语法错误。

解构时也可以指定默认值。举例：

```javascript
let [a = 3, b = 4] = [undefined, 2]
let {x, y: ww = 2} = {x: 2}
console.log(ww) // 2
```

解构还能够用在函数参数中，同时还可以和默认值结合。解构默认值+参数默认值的混合形式举例：

```javascript
function f3({x = 10} = {}, {y} = {y: 10}) {}
```

### 对象字面量扩展

1. 属性简写和方法简写

2. ES5 Getter/Setter

```javascript
let o = {
  __id: 10,
  get id () {return this.__id++},
  set id (v) {this.__id = v}
}
```

setter函数必须有且仅有一个参数，否则都会报语法错误。

3. 计算属性名

对象字面量中的属性名还可以是计算属性名，也就是通过JavaScript表达式计算得到，只需要将表达式使用[]进行包裹即可。除此之外，计算属性名还可以用在简写属性名或者简写方法名中。

4. 对象简写方法中的super对象

鉴于JavaScript原型类而非类对象的本质，super对象除了在类中使用之外，还可以在**对象字面量的简写方法**中使用，通过该对象来访问原型链上父类的属性和方法。但同时，只允许以super.XXX的形式出现，而不能是super()。

```javascript
let o1 = {foo () {console.log('o1.foo')}}
let o2 = {}
let o3 = {foo () {super.foo();console.log('o3.foo')}}
Object.setPrototypeOf(o3, o2)
Object.setPrototypeOf(o2, o1)
o3.foo() // 'o1.foo' 'o3.foo'
```

### 模板字面量

#### 插入字符串字面量

插入字符串字面量：使用`作为界定符，该字面量支持插入基本的JavaScript表达式，表达式使用${...}进行包裹，而且会被自动解析和求值。

插入字符串字面量的一个特点是：允许在字面量中进行换行，并且最终结果会保留换行符

#### 标签模板字面量

标签模板字面量由两部分构成，第一部分就是标签部分，即`...`符号前面的表达式，该表达式的值为一个函数（只要表达式的最终结果是函数即可），用来处理后面的插入字符串字面量并返回处理结果，返回的结果也作为最终标签模板字面量的值。第二部分就是插入字符串字面量。标签部分的函数接收的参数及其含义如下：

```javascript
let o = {__id: 10}
function foo(strings, ...values) {}
// 以处理tag`${o.__id}Jack${oy.__id}bye`这个插入字符串字面量为例，最终foo函数接收的参数值如下：
// strings：["", "Jack", "bye"]
// values: [10, 10]
// 在实际使用中我们要把values中的值看成是分隔符，它将插入字符串字面量中的字符串分隔开了
```

