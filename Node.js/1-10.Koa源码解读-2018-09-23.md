## Koa简介

Koa是在Node.js http模块的基础上做的一层封装，主要引入了context对象和中间件的思想，原本对于request和response的处理直接转化为对context对象进行操作，Koa针对每一个请求都创建了对应的context对象，请求中包含的信息也附加在context对象上。

使用Koa创建服务端也变得很简单，直接构造Koa实例即可。

### 中间件处理机制

Koa中间件的形式：

```javascript
let Koa = require('Koa')
let app = new Koa()
app.use(async (ctx, next) => {
	...
})
```

从Koa的源码来看，可以在应用中接入多个中间件，如果在某个中间件中需要将当前请求传递给下一个中间件处理，可以在中间件函数中调用参数next。在经过多个中间件处理之后，Koa会根据ctx.body中的值设置响应内容。Koa会从第一个中间件开始处理请求，如果中间件中没有调用next，则请求不会传递到后续的中间件中。next不一定要在中间件的最后调用。举例：

```javascript
app.use(async (ctx, next) => {
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
});
```

Koa中间件核心部分源码如下：

```javascript
class Application extends Emitter {
	...
	listen(...args) {
		const server = http.createServer(this.callback());
		return server.listen(...args);
	}
	callback() {
		const fn = compose(this.middleware);
		if (!this.listenerCount('error')) this.on('error', this.onerror);
		const handleRequest = (req, res) => {
		  const ctx = this.createContext(req, res); // 针对每个请求创建独立的context对象
		  return this.handleRequest(ctx, fn);
		};
		return handleRequest;
	}
	handleRequest(ctx, fnMiddleware) {
		const res = ctx.res;
		res.statusCode = 404;
		const onerror = err => ctx.onerror(err);
		const handleResponse = () => respond(ctx);
		onFinished(res, onerror);
		// 将context传递到中间件中进行处理，然后生成响应
		return fnMiddleware(ctx).then(handleResponse).catch(onerror);
	}
}
// compose函数源码
function compose (middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }
  return function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
      	// 由此可见，传递到每个中间件函数中的next函数实际上就是经过绑定后的dispatch函数，当在中间件函数中调用此函数时会给dispatch函数传递下一个中间件在中间件列表中的索引。同时也看出中间件函数需要返回Promise对象
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```

当中间件对请求处理完毕之后，就会根据设置的context.body属性来返回最终的响应内容，从下面的源码可以看出，我们设置context.body时可以是Buffer对象、字符串或者流。响应部分源码：

```javascript
function respond(ctx) {
  // allow bypassing koa
  if (false === ctx.respond) return;

  const res = ctx.res;
  if (!ctx.writable) return;

  let body = ctx.body;
  const code = ctx.status;

  // 状态码为204，205，304是不需要返回响应内容的
  if (statuses.empty[code]) {
    // strip headers
    ctx.body = null;
    return res.end();
  }

  if ('HEAD' == ctx.method) {
    if (!res.headersSent && isJSON(body)) {
      ctx.length = Buffer.byteLength(JSON.stringify(body));
    }
    return res.end();
  }

  // status body
  if (null == body) {
    body = ctx.message || String(code);
    if (!res.headersSent) {
      ctx.type = 'text';
      ctx.length = Buffer.byteLength(body);
    }
    return res.end(body);
  }

  // responses
  if (Buffer.isBuffer(body)) return res.end(body);
  if ('string' == typeof body) return res.end(body);
  if (body instanceof Stream) return body.pipe(res);

  // body: json
  body = JSON.stringify(body);
  if (!res.headersSent) {
    ctx.length = Buffer.byteLength(body);
  }
  res.end(body);
}
```

### koa属性委托机制

koa中提供了context对象，关于请求和相应的信息都是通过该对象进行获取或者设置。context对象上的req和res分别保留了原生Node.js的请求和响应对象，而context.request和context.response则保存的是Koa框架对原生请求和响应对象的修正。另外，通过委托机制，也就是将部分关键属性和方法从context.request和context.response对象上直接搬到了context对象，在context对象上对这些属性进行修改或者调用这些方法（这样修改属性或者调用方法更加简洁，可以省掉中间的request属性和response属性），实际上修改的是context.request和context.response上同名属性，或者调用对应的方法。比如我们经常设置的context.body实际上设置的是context.response.body。

### koa错误处理机制

通过Koa函数创建出来的app实例本身也具有context属性，它指向的是每个请求单独创建出来的context对象的原型。具体原型链的结构如下：

ctx -> app.context -> 由context.js导出的context对象，在该原型对象上定义了onerror方法，用来处理处理请求过程中出现的错误

```javascript
// context.js
const proto = module.exports = {
	...
	onerror(err) {
		// don't do anything if there is no error.
		// this allows you to pass `this.onerror`
		// to node-style callbacks.
		if (null == err) return;

		if (!(err instanceof Error)) err = new Error(util.format('non-error thrown: %j', err));

		let headerSent = false;
		if (this.headerSent || !this.writable) {
		  headerSent = err.headerSent = true;
		}

		// delegate
		this.app.emit('error', err, this);

		// nothing we can do here other
		// than delegate to the app-level
		// handler and log.
		if (headerSent) {
		  return;
		}

		const { res } = this;

		// first unset all headers
		/* istanbul ignore else */
		if (typeof res.getHeaderNames === 'function') {
		  res.getHeaderNames().forEach(name => res.removeHeader(name));
		} else {
		  res._headers = {}; // Node < 7.7
		}

		// then set those specified
		this.set(err.headers);

		// force text/plain
		this.type = 'text';

		// ENOENT support
		if ('ENOENT' == err.code) err.status = 404;

		// default to 500
		if ('number' != typeof err.status || !statuses[err.status]) err.status = 500;

		// respond
		const code = statuses[err.status];
		const msg = err.expose ? err.message : code;
		this.status = err.status;
		this.length = Buffer.byteLength(msg);
		this.res.end(msg);
	}
}
```

### koa-router

